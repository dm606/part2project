type Null = 

type Bool = true : Bool | false : Bool

type Nat = zero : Nat | succ : Nat -> Nat

type Vec (A : U) : Nat -> U =
  | nil : Vec A zero
  | cons : (n : Nat) -> A -> Vec A n -> Vec A (succ n)

type Fin : Nat -> U =
  | fzero : (n : Nat) -> Fin (succ n)
  | fsucc : (n : Nat) -> (i : Fin n) -> Fin (succ n)

let rec is_even : Nat -> Bool = function
  | zero -> true
  | succ (succ x) -> is_even x
  | succ zero -> false

let maj : Bool * Bool * Bool -> Bool = function
  | true, true, true -> true
  | true, false, z -> z
  | false, y, true -> y
  | x, true, false -> x
  | false, false, false -> false

(*
let rec nth : (A : U) -> (m : Nat) -> Vec A (succ m) -> Fin (succ m) -> A =
  fun A n -> function cons .A .n a tl -> (function
      | fzero .n -> a
      | fsucc .n i -> nth A n tl i)))
*)
(*let rec map : (A : U) -> (B : U) -> (A -> B) -> (n : Nat) -> Vec A n
           -> Vec B n =
  fun A B f _ -> function
    | nil .A -> nil B
    | cons .A n a tl -> cons B n (f a) (map A B f n tl)
*)
let rec map : (A : U) -> (B : U) -> (A -> B) -> (n : Nat) -> Vec A n
           -> Vec B n =
  fun A B f -> (function
    | zero -> (function nil .A -> nil B)
    | succ n -> (function cons .A .n a tl -> cons B n (f a) (map A B f n tl)))

let rec add : Nat -> Nat -> Nat =
  fun x y ->
    match x with
    | zero -> y
    | (succ z) -> succ (add z y)

(*let rec append : (A : U) -> (n : Nat) -> (m : Nat) -> Vec A n -> Vec A m
              -> Vec A (add n m) =
  fun A n m x y ->
    match x with
    | nil .A -> y
    | cons .A .n a z -> cons A (add n m) a (append A n m z y)
*)
(*let rec append : (A : U) -> (n : Nat) -> (m : Nat) -> Vec A n -> Vec A m
              -> Vec A (add n m) =
  fun A n m x y ->
    (let f : Vec A n -> Vec A (add n m) = function
      | nil .A -> y
      | cons .A .n a z -> cons A (add n m) a (append A n m z y) in
    f x)
*)

let rec append : (A : U) -> (n : Nat) -> (m : Nat) -> Vec A n -> Vec A m -> Vec
A (add n m) =
  fun A ->
    function
    | zero -> (fun m -> function nil .A -> (fun l -> l))
    | succ n ->
        (fun m -> function cons .A .n a z ->
          (fun y -> cons A (add n m) a (append A n m z y)))

let Not : U -> U = fun A -> A -> Null

type Or (A : U) (B : U) : U =
  | inl : A -> Or A B
  | inr : B -> Or A B

type Eq (A : U) (a : A) : A -> U =
  | refl : Eq A a a

(*
type DistinctList (A : U) (NotEqual : A -> A -> U) : U =
  | dnil : DistinctList A NotEqual
  | dcons : (a : A) -> (l : DistinctList A NotEqual)
         -> Fresh A NotEqual a l -> DistinctList A NotEqual
and let rec Fresh : (A : U) -> (NotEqual : A -> A -> U) -> (a : A)
                 -> (l : DistinctList A NotEqual) -> U =
  fun A NotEqual a ->
    function
    | dnil _ _ -> Unit
    | dcons _ _ b l _ -> (NotEqual a b) * (Fresh A NotEqual a l)
*)

let false_elim : (A : U) -> Null -> A =
  fun _ -> function

let proof : (A : U) -> (B : U) -> (Not A) * (Or A B) -> B =
  fun A B -> function
  | a, inl .A .B x -> false_elim B (a x)
  | a, inr .A .B x -> x

let proof2 : (n : Nat) -> Not (Eq Nat n zero) -> (m : Nat) * Eq Nat n (succ m) =
  function
  | zero -> (
      let t : U = (m : Nat) * Eq Nat zero (succ m) in
      (fun p -> false_elim t (p (refl Nat zero))))
  | succ x -> (fun p -> (x, refl Nat (succ x)))

let one : Nat = succ zero
let two : Nat = succ one
let three : Nat = succ two
let four : Nat = succ three
let five : Nat = succ four
let six : Nat = succ five
