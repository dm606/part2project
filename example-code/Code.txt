type Null = 

type Nat = zero : Nat | succ : Nat -> Nat

type Vec (A : U) : Nat -> U =
  | empty : Vec A zero
  | cons : (n : Nat) -> A -> Vec A n -> Vec A (succ n)

type Fin : Nat -> U =
  | fzero : (n : Nat) -> Fin (succ n)
  | fsucc : (n : Nat) -> (i : Fin n) -> Fin (succ n)

let rec nth : (A : U) -> (m : Nat) -> Vec A m -> Fin m -> A =
  fun A m ->
    function cons _ a l -> (
      function
      | fzero _ -> a
      | fsucc _ i -> nth A m l i)

let rec map : (A : U) -> (B : U) -> (A -> B) -> (n : Nat) -> Vec A n
           -> Vec B n =
  fun A B f _ ->
    function
    | empty A -> empty B
    | cons A m a l -> cons B m (f a) (map A B f m l)

let rec add : Nat -> Nat -> Nat =
  fun x y ->
    match x with
    | zero -> y
    | (succ z) -> succ (add z y)

let rec append : (A : U) -> (n : Nat) -> (m : Nat) -> Vec A n -> Vec A m
              -> Vec A (add n m) =
  fun A n m x y ->
    match x with
    | empty A -> y
    | cons A n a z -> cons A (add n m) a (append A n m z y)

let Not : U -> U = fun A -> A -> Null

type Or (A : U) (B : U) : U =
  | inl : A -> Or A B
  | inr : B -> Or A B

type Eq (A : U) (a : A) : A -> U =
  | refl : Eq A a a

type DistinctList (A : U) (NotEqual : A -> A -> U) : U =
  | dempty : DistinctList A NotEqual
  | dcons : (a : A) -> (l : DistinctList A NotEqual)
         -> Fresh A NotEqual a l -> DistinctList A NotEqual
and let rec Fresh : (A : U) -> (NotEqual : A -> A -> U) -> (a : A)
                 -> (l : DistinctList A NotEqual) -> U =
  fun A NotEqual a ->
    function
    | dempty _ _ -> Unit
    | dcons _ _ b l _ -> (NotEqual a b) * (Fresh A NotEqual a l)

let false_elim : (A : U) -> Null -> A =
  fun _ -> function

let proof : (A : U) -> (B : U) -> (Not A) * (Or A B) -> B =
  fun A B -> function
  | a, inl x -> false_elim B (a x)
  | a, inr x -> x

let proof2 : (n : Nat) -> Not (Eq Nat n zero) -> (m : Nat) * Eq Nat n (succ m) =
  fun n -> fun p ->
    match n with 
    | zero -> false_elim ((m : Nat) * Eq Nat n (succ m)) (p (refl Nat zero))
    | succ x -> (x, refl Nat n)

let one : Nat = succ zero
let two : Nat = succ one
let three : Nat = succ two
let four : Nat = succ three
let five : Nat = succ four
let six : Nat = succ five
