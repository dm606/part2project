open AbsConcrete

(** raised when an invalid value of type expr is used *)
exception Invalid_expression of string

(** raised when a construtor which has not been declared is used *)
exception Constructor_not_defined of string

(** the type of the identifiers used to refer to metavariables *)
(* TODO: Make abstract *)
type meta_id = bool * int

(** crates a metavariable *)
val create_metavariable : unit -> meta_id

(** crates a metavariable which can be used for an implicit argument *)
val create_implicit_metavariable : unit -> meta_id

(** [is_implicit id] returns true iff [id] refers to a metavariable which
    used for an implicit argument *)
val is_implicit : meta_id -> bool

(** converts the id to a string *)
val string_of_id : meta_id -> string

(** compare meta_ids *)
val meta_id_compare : meta_id -> meta_id -> int

(** the type of environments used for desugaring and resugaring *)
type envt

(** the empty environment *)
val empty_env : envt

(* mk_env (binders, constructors) returns the environment which contains the
 * names of binders in binders, and all of the constructors in constructors *)
val mk_env : string list * (string * string) list -> envt

(** The type of desugared expressions.
 * Expressions use de Bruijn indices, which are allocated as follows:
 * * One index is allocated in the body of a lambda abstraction, if the binder
 *     is not Underscore
 * * One index is allocated on the right of a pi or sigma type, if the binder is
 *     not underscore
 * * On the right hand side of a case, one index is allocated for every binder
 *     in the corresponding pattern; the indices increase from right to left
 * * In the body of a let or let rec, one index is allocated per let rec
 *     in the same declaration, only including the current declaration for a let
 *     rec. Declarations which appear before the current one get a lower index
 *     than those after it.
 * * In the body of a declaration, one index is allocated per let or let rec;
 *     closer lets get smaller indices.
 * * In the indices of a type or the type of a constructor, one index is
 *     assigned for each binder in the parameters of the type. The indices
 *     increase from right to left. *)
type expression =
  | Pair of expression * expression
  | Lambda of binder * expression
  | LambdaImplicit of binder * expression
  | Pi of binder * expression * expression
  | PiImplicit of string * expression * expression
  | Sigma of binder * expression * expression
  | Function of (pattern * expression) list
  | LocalDeclaration of declaration list * expression
  | Application of expression * expression
  | ApplicationImplicit of expression * expression
  | Universe of int
  | UnitType
  | Unit
  | Index of int (* de Bruijn index *)
  | Constructor of string
  | Proj1 of expression
  | Proj2 of expression
  (* A metavariable. Each metavariable is assigned a unique ID for use in the
   * constraints generated by the type checker *)
  | Meta of meta_id
and binder =
  | Underscore
  (* Since de Bruijn indices are used, the name used is not necessary; it is
   * only kept for pretty-printing *)
  | Name of string 
and pattern =
  | PatternPair of pattern * pattern
  | PatternApplication of string * (bool * pattern) list (* Constructor application *)
  | PatternBinder of string (* name only needed for pretty-printing *)
  | PatternUnderscore
  | PatternInaccessible of expression
and declaration =
  (* Names only used for pretty-printing, except for constructor names *)
  | Let of string * expression * expression
  | LetRec of string * expression * expression
  | Type of string * parameter list
          * expression * (string * expression) list
and parameter =
  | Parameter of string * expression
  | ParameterImplicit of string * expression

(** returns all of the metavariables mentioned in the expression *)
val get_metavariables : expression -> meta_id list

(** returns all of the metavariables mentioned in the declaration *)
val get_metavariables_decl : declaration -> meta_id list

(** determines if an expression references a constructor *)
val does_not_mention : string -> expression -> bool

(** adds each of the lets and let recs in the list to the environment *)
val add_all_declaration_binders : envt -> decl list -> envt

(** removes the syntactic sugar from the expression, in the given environment *)
val desugar_expression : envt -> exp -> expression

(** removes the syntactic sugar from the list of declarations, in the given
 * environment *)
val desugar_declarations : envt -> decl list -> declaration list

(** adds syntactic sugar to the expression in the given environment for pretty
 * printing *)
val resugar_expression : envt -> expression -> exp

(** adds syntactic sugar to the declarations in the given environment for pretty
 * printing *)
val resugar_declarations : envt -> declaration list -> decl list

(** converts the given expression to a string *)
val print_expression : envt -> expression -> string

(** converts the given pattern to a string *)
val print_pattern : envt -> pattern -> string

(** converts the given declarations to a string *)
val print_declarations : envt -> declaration list -> string

